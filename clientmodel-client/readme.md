# Differences between Azure.Core-based clients and System.ClientModel-based clients

## Overview

Differences fall into the following categories:

- [Type name changes](#type-names)
- [Type usage changes](#type-usage)
- [Type removals](#type-removal)
- [Client API changes](#client-apis)
- [Nullable annotations](#nullable-annotations)

## Type names

| Azure.Core type | System.ClientModel type |
| ------------- | ------------- |
| `AzureKeyCredential` | `ApiKeyCredential` |
| `AzureKeyCredentialPolicy` | `ApiKeyAuthenticationPolicy` |
| `ClientOptions` | `ClientPipelineOptions` |
| `ErrorOptions` | `ClientErrorBehaviors` |
| `HttpClientTransport` | `HttpClientPipelineTransport` |
| `HttpMessage` | `PipelineMessage` |
| `HttpPipeline` | `ClientPipeline` |
| `HttpPipelinePolicy` | `PipelinePolicy` |
| `HttpPipelinePosition` | `PipelinePosition` |
| `HttpPipelineTransport` | `PipelineTransport` |
| `NullableResponse<T>` | `ClientResult<T?>` |
| `Request` | `PipelineRequest` |
| `RequestContent` | `BinaryContent` |
| `RequestContext` | `RequestOptions` |
| `RequestHeaders` | `PipelineRequestHeaders` |
| `RequestFailedException` | `ClientResultException` |
| `Response` | `PipelineResponse` |
| `Response<T>` | `ClientResult<T>` |
| `ResponseClassifier` | `PipelineMessageClassifier` |
| `ResponseHeaders` | `PipelineResponseHeaders` |
| `RetryPolicy` | `ClientRetryPolicy` |

[Azure.Core APIView](https://apiview.dev/Assemblies/Review/ba87b735158144eea6cabe21a2c58dde)
[System.ClientModel APIView](https://apiview.dev/Assemblies/Review/1b123e7a51d44ebe945f0212ee039c65)

## Type usage

Usage of ClientModel types differ from Azure.Core types in the following areas:

- Call to `HttpPipelineBuilder.Build` is replaced by `ClientPipeline.Create`.
- Client endpoint is a local variable and not a property on client options.
- `ClientPipeline.Send` does not take a cancellation token.
- Generated `PipelineMessageClassifier` instances are created using `PipelineMessageClassifier.Create` instead of classifier constructor.
- `PipelineMessage.Apply(options)` is called at the end of a `CreateRequest` method instead of at the beginning.
- `PipelineRequest.Method` is set from a string value instead of an extensible enum value.
- Instances of `ClientResultException` created in async contexts use `ClientResultException.CreateAsync` instead of exception constructor.

## Type removal

A number of types have been removed from System.ClientModel.  As a result client method implementations will change as follows.

- `ClientDiagnostics` is removed.  As a result, calls `CreateScope`, `scope.Start` and try/catch block around method implementation are removed.
- `RequestUriBuilder` is replaced by BCL `Uri` type.  `CreateRequest` methods use BCL `UriBuilder` to create the request URI.
- Shared source type `RawRequestUriBuilder` is removed.  Generated clients escape URI query parameter values inline.
- Shared source type `HttpPipelineExtensions` is removed.  Generated clients call `pipeline.Send` and check `response.IsError` inline in the protocol method.
- There are no pageable or long-running operations in `System.ClientModel`-based clients today.

## Client APIs

System.ClientModel-based clients should have the same APIs as Azure.Core-based clients (modulo type name changes) in all areas, except the following.

- Convenience methods do not take `CancellationToken` parameter.  As a result, convenience methods do not create an instance of `RequestOptions` to pass to the nested protocol method call.
- Protocol methods return `ClientResult` instead of `PipelineResponse`.  As a result, convenience methods first call `result.GetRawResponse` to get the `PipelineResponse` they use to create the method return value.  Similarly, protocol methods call `ClientResult.FromResponse` to create the return value instead of returning the message.Response.

## Nullable annotations

System.ClientModel-based clients use nullable annotations to indicate that a convenience method may return null from `result.Value` instead of a model instance.  Whether or not a client has such a service method in its first release, because enabling nullable annotations for an assembly is a breaking change, nullable annotations must be turned on from the start in case such an operation is ever added by the service.

The changes needed to support nullable annotations are:

- Client's `.csproj` file contains `<Nullable>enable</Nullable>`.
- Optional `ClientPipelineOptions` parameter to client constructor is nullable.
- Optional `RequestOptions` parameter to protocol methods is nullable.
- Protocol methods set `response` to non-nullable `PipelineResponse` using null-forgiving operator `!`.
- Lazily-initialized `PipelineMessageClassifier` is nullable.
- Model files must either remove `// <auto-generated/>` or add `#nullable enabled`.
- Optional `ModelReaderWriterOptions` parameter to model read/write routines is nullable.
- Optional properties that are reference types use nullable annotation.  Update to constructor and property definition.
- Model deserialization routines throw `JsonException` if `(element.ValueKind == JsonValueKind.Null)`.
- Nested models that can be deserialized correctly from JSON `null` are set to null by the parent model deserialization routine.
- Model deserialization routines declare variables used to read required properties from JSON as nullable.  These variables are checked to validate that they have been populated prior to creating type instance.  If they do not have values, throw `JsonException`.
- Model deserialization routines use `valueTypeVariable!.Value` to pass required value type property to type constructor.
- Model deserialization routines deserializing collections of non-nullable values check for null when enumerating collection values and throw `JsonException` if a value is null.
- Model serialization routines use null-forgiving operator `!` for optional properties that have already been checked for null by call to `OptionalProperty.IsDefined`.
- Models that are extensible enums use nullable annotation in `Equals` method override.
