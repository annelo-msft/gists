# Differences between Azure.Core-based clients and System.ClientModel-based clients

## Overview

Differences fall into the following major categories:

- [Type name changes](#type-names)
- [Type usage changes](#type-usage)
- [Type removals](#type-removal)
- [Client API changes](#client-apis)
- [Nullable annotations](#nullable-annotations)

## Type names

Mapping of Azure.Core type names to System.ClientModel type names:

## Type usage

Usage of ClientModel types differ from Azure.Core types in the following areas

## Type removal

A number of shared source types no longer exist in System.ClientModel.  As a result client method implementations will change as follows.

## Client APIs

System.ClientModel-based clients should have the same APIs as Azure.Core-based clients (modulo type name changes) in all areas, except the following.

- Convenience methods do not take `CancellationToken` parameter.
- Protocol methods return `ClientResult` instead of `PipelineResponse`.

## Nullable annotations

System.ClientModel-based clients use nullable annotations to indicate that a convenience method may return null from `result.Value` instead of a model instance.  Whether or not a client has such a service method in its first release, because enabling nullable annotations for an assembly is a breaking change, nullable annotations must be turned on from the start in case such an operation is ever added by the service.

The changes needed to support nullable annotations are:

- Client's `.csproj` file contains `<Nullable>enable</Nullable>`.
- Optional `ClientPipelineOptions` parameter to client constructor is nullable.
- Optional `RequestOptions` parameter to protocol methods is nullable.
- Protocol methods set `response` to non-nullable `PipelineResponse` using null-forgiving operator `!`.
- Lazily-initialized `PipelineMessageClassifier` is nullable.
- Model files must either remove `// <auto-generated/>` or add `#nullable enabled`.
- Optional `ModelReaderWriterOptions` parameter to model read/write routines is nullable.
- Optional properties that are reference types use nullable annotation.  Update to constructor and property definition.
- Model deserialization routines throw `JsonException` if `(element.ValueKind == JsonValueKind.Null)`.
- Nested models that can be deserialized correctly from JSON `null` are set to null by the parent model deserialization routine.
- Model deserialization routines declare variables used to read required properties from JSON as nullable.  These variables are checked to validate that they have been populated prior to creating type instance.  If they do not have values, throw `JsonException`.
- Model deserialization routines use `valueTypeVariable!.Value` to pass required value type property to type constructor.
- Model deserialization routines deserializing collections of non-nullable values check for null when enumerating collection values and throw `JsonException` if a value is null.
- Model serialization routines use null-forgiving operator `!` for optional properties that have already been checked for null by call to `OptionalProperty.IsDefined`.
- Models that are extensible enums use nullable annotation in `Equals` method override.
